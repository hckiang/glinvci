% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ou.R
\name{ou_diagH}
\alias{ou_diagH}
\alias{dou_diagH}
\alias{hou_diagH}
\alias{ou_logdiagH}
\alias{dou_logdiagH}
\alias{hou_logdiagH}
\alias{ou_symH}
\alias{dou_symH}
\alias{hou_symH}
\alias{ou_spdH}
\alias{dou_spdH}
\alias{hou_spdH}
\title{Restrict the drift matrix of OU model.}
\usage{
ou_diagH(parfn)

dou_diagH(jacfn)

hou_diagH(hessfn)

ou_logdiagH(parfn)

dou_logdiagH(jacfn)

hou_logdiagH(hessfn)

ou_symH(parfn)

dou_symH(jacfn)

hou_symH(hessfn)

ou_spdH(parfn, log = T)

dou_spdH(jacfn, log = T)

hou_spdH(hessfn, jacfn, log = T)
}
\arguments{
\item{parfn}{A function that maps from the user-parametrisation to the underlying Gaussian parameters.
Each of them returns a vector of concatenated \eqn{(\Phi, w, V')}, where \eqn{V'} is the lower triangular
part of \eqn{V}, and accepts four arguments: a vector of parameters whose length is specified
by the \code{pardims} argument to the \code{glinv_gauss} function, the branch length leading to the currently processing node, 
a vector of factors with three levels indicating which dimensions are missing or lost in the mother of
the current node, and a vector of factors with the same three levels indicating missingness of the current
node.}

\item{jacfn}{A function that accepts the same arguments as \code{parfn} and returns the Jacobian
of \code{parfn}.}

\item{hessfn}{A function that accepts the same arguments as \code{parfns} and returns a list of three 3D arrays,
named \code{Phi}, \code{w}, \code{V} respectively inside the list. \code{((hessfn)(...))$Phi[m,i,j]}
contains the cross second-order partial derivative of \eqn{\Phi_m} (here we treat the matrix
\eqn{\Phi} as a column-major-flattened vector) with respect to the \eqn{i}-th and\eqn{j}-th parameters
in the joint \eqn{(H,\theta,\Sigma_x)} vector, and
\code{((hessfn)(...))$w[m,i,j]} and \code{((hessfn)(...))$V[m,i,j]}
analogously contains second-order derivative with respect to \eqn{w_m} and \eqn{V'_m}.}

\item{log}{Whether or not some elements of the parameters should be passed to
their logarithm in the resulting reparametrisation. See the Details
section.}
}
\value{
\code{ou_*}, \code{dou_*}, and \code{hou_*} returns, respectively,
               a function that accepts the same form of arguments, and returns the
               same form of output, as the \code{parfn}, \code{jacfn}, and
               \code{hessfn} arguments. These function should be ready to be passed
               to the \code{parfns}, \code{parjacs}, and \code{parhess} arguments
               of \code{\link{lik.glinv}}.
}
\description{
\code{ou_diagH} restricts the drift matrix of an OU model to
diagonal matrices.

\code{ou_logdiagH} restricts the drift matrix of an OU model to
positively definite diagonal matrices. A diagonal matrix is positively
definite if and only if all of its diagonal entries are positive;
therefore it parametrises the diagonals to their logarithm to
facilitate unconstrained optimisation.

\code{ou_symH} restricts the drift matrix of an OU model to
symmetric matrices. It parametrises the space of symmetric
matrices by the lower-triangular part.

\code{ou_spdH} restricts the drift matrix of an OU model to
symmetric positively definite matrices, either by its Cholesky factor,
or by a modified Cholesky factor in which the diagonals are passed
to their logarithm to ensure that they are all positive. The likelihood
surface will be multi-modal in the non-logarithm version because any
arbitrary sign change in the Cholesky factor's diagonals does not change
the likelihood value.
}
\details{
\subsection{How reparametrisation and restriction works}{

In the simplest form, without any restriction or reparametrisation, the user typically
needs to pass \code{oupar}, \code{oujac}, \code{ouhess}, all of which are simply
functions which maps from the OU parameters \eqn{(H,\theta,\Sigma_x)} to the Gaussian
paramters \eqn{(\Phi_i,w_i,V'_i)} for each node. For example:
\preformatted{
        mod.full = glinv(tree, x0, my_data,
                         parfns  = oupar,
                         pardims = nparams_ou(k),
                         parjacs = oujac,
                         parhess = ouhess)
}
If one would like to restrict \eqn{H} to only positively definite diagonal matrices,
then the call should become
\preformatted{
        mod.pddiag = glinv(tree, x0, my_data,
                           parfns  = ou_logdiagH(oupar),
                           pardims = nparams_ou_logdiagH(k),
                           parjacs = dou_logdiagH(oujac),
                           parhess = hou_logdiagH(ouhess))
}
Note that there is a naming convention that \code{ou_*} should be applied to `oupar`,
\code{dou_*} to `oujac`, and \code{hou_*} to `ouhess`. \code{d} stands for `derivative'
and \code{h} stands for `Hessian'.

In the above call, ou_logdiagH(oupar) accepts the \code{oupar} function as argument
and returns a new function. This new function behaves the same way as oupar itself,
except that it expects its first argument (which is the model parameters) to be of
lower dimension, only consisting of \eqn{(h,\theta,\Sigma_x)} where \eqn{h} is the
diagonal vector of \eqn{H}. The following example should be illustrative:
\preformatted{
        f = ou_logdiagH(oupar)
        par.full = list(H     = matrix(c(3,0,0,2),2,2),
                        theta = c(4,5),
                        sig_x = c(1,0,1))
        par.restricted = list(H     = log(diag(par.full$H)),
                              theta = par.full$theta,
                              sig_x = par.full$sig_x)
        print(all.equal(f(unlist(par.restricted),1,NULL,NULL),
                        oupar(unlist(par.full),1,NULL,NULL)))
        # [1] TRUE
}
}

\subsection{Details about each pre-defined restrictions}{
The following table summarises all the pre-defined \code{ou_*} functions.
\tabular{ll}{
  \strong{R function}   \tab \strong{Restriction}\cr
  \code{*_diagH}    \tab \eqn{(h,\theta,\Sigma_x)}, with \eqn{h=diag(H)}\cr
  \code{*_logdiagH} \tab \eqn{(log(h),\theta,\Sigma_x)}, with \eqn{h=diag(H)}\cr
  \code{*_symH}     \tab \eqn{(L,\theta,\Sigma_x)}, with \eqn{L} being lower-triangular part of H\cr
  \code{*_spdH, log=F}  \tab \eqn{(L,\theta,\Sigma_x)}, with \eqn{L} being Cholesky factor of H\cr
  \code{*_spdH, log=T}  \tab \eqn{(L',\theta,\Sigma_x)} where \eqn{L'} equals \eqn{L}, except that on the diagonals \eqn{L'_i} = \eqn{log L_i}
}
By Cholesky factor, we mean the only the non-zero part of the lower-triangular Cholesky factor.
}
}
